You are a helpful data analysis bot, you are equiped with an mcp server 'run_python' which helps you run
python code in a separate interpreter allowing you to perform data analysis without having to load all the data
into your context window, also there a few caveats, it has a script executor enginer and not a jupter_kernel
so when you call the tool again it will not retain the results/memory of what you executed earlier for example:
You established a variable a = 10, in your first pass then if you try access it in the second pass like so print(a), it will
not work, some logic for loading the dependencies, so every time you execute some code and get a result and you wish to build
on top of it, you are to rewrite the imports and the declarations etc. again. All the values are in rupees.

when asked to "execute analysis" you are to always run this script using run python mcp server, make sure to not make any changes as its a critical step:

import pandas as pd
import numpy as np
import json
import sys
from pyodide.http import pyfetch
from io import StringIO
import asyncio

# --- CONFIGURATION & ASSUMPTIONS ---
CONFIG = {
    "profit_margin": 0.25,
    "dormancy_threshold_days": 60,
    "new_customer_threshold_days": 30,
}

async def load_csv_from_url(url):
    response = await pyfetch(url)
    if not response.ok:
        raise Exception(f"HTTP {response.status}: {response.status_text}")
    csv_text = await response.string()
    csv_data = StringIO(csv_text)
    df = pd.read_csv(csv_data)
    return df

async def analyze_kpis(csv_url):
    try:
        df = await load_csv_from_url(csv_url)
    except Exception as e:
        return json.dumps({"error": str(e)}, indent=2)

    total_customers = len(df)
    new_customers_df = df[df['Days_Since_First_Order'] <= CONFIG['new_customer_threshold_days']]
    dormant_customers_df = df[(df['Days_Since_Last_Order'] > CONFIG['dormancy_threshold_days']) & (df['Days_Since_First_Order'] > CONFIG['new_customer_threshold_days'])]
    active_customer_mask = ~df.index.isin(new_customers_df.index) & ~df.index.isin(dormant_customers_df.index)
    active_customers_df = df[active_customer_mask]

    customer_segments = {
        "total_customers": total_customers,
        "new_customers": {
            "count": len(new_customers_df),
            "percentage": round(len(new_customers_df) / total_customers * 100, 2),
            "avg_first_order_value": round(new_customers_df['Average_Spend_Per_Order'].mean(), 2) if len(new_customers_df) > 0 else 0
        },
        "active_customers": {
            "count": len(active_customers_df),
            "percentage": round(len(active_customers_df) / total_customers * 100, 2),
            "avg_clv": round(active_customers_df['Total_Spend_By_Customer'].mean(), 2) if len(active_customers_df) > 0 else 0,
            "avg_orders": round(active_customers_df['Total_Orders_Placed'].mean(), 2) if len(active_customers_df) > 0 else 0
        },
        "dormant_customers": {
            "count": len(dormant_customers_df),
            "percentage": round(len(dormant_customers_df) / total_customers * 100, 2),
            "avg_clv_before_dormancy": round(dormant_customers_df['Total_Spend_By_Customer'].mean(), 2) if len(dormant_customers_df) > 0 else 0
        }
    }

    total_revenue = df['Total_Spend_By_Customer'].sum()
    total_orders = df['Total_Orders_Placed'].sum()
    financial_summary = {
        "total_revenue": int(total_revenue),
        "estimated_total_profit": int(total_revenue * CONFIG['profit_margin']),
        "overall_aov": round(total_revenue / total_orders, 2) if total_orders > 0 else 0,
        "overall_avg_clv": round(df['Total_Spend_By_Customer'].mean(), 2),
    }

    multi_order_customers = active_customers_df[active_customers_df['Total_Orders_Placed'] > 1]
    if len(multi_order_customers) > 0:
        order_freq_stats = multi_order_customers['Total_Orders_Placed'].describe()
        stamp_card_analysis = {
            "target_customer_count": len(multi_order_customers),
            "order_frequency_distribution": {
                "mean": round(order_freq_stats['mean'], 2),
                "std": round(order_freq_stats['std'], 2),
                "min": int(order_freq_stats['min']),
                "25%": round(order_freq_stats['25%'], 2),
                "50%": round(order_freq_stats['50%'], 2),
                "75%": round(order_freq_stats['75%'], 2),
                "max": int(order_freq_stats['max'])
            },
            "suggestion": f"Most active customers place between {int(order_freq_stats['25%'])} and {int(order_freq_stats['75%'])} orders. A 5 or 7 stamp card could be optimal."
        }
    else:
        stamp_card_analysis = {
            "target_customer_count": 0,
            "order_frequency_distribution": {},
            "suggestion": "No multi-order active customers found for stamp card analysis."
        }

    if len(dormant_customers_df) > 0:
        avg_dormant_spend = dormant_customers_df['Average_Spend_Per_Order'].mean()
        recency_stats = df['Days_Since_Last_Order'].describe()
        miss_you_analysis = {
            "target_customer_count": len(dormant_customers_df),
            "dormancy_trigger_point_days": CONFIG['dormancy_threshold_days'],
            "avg_spend_of_dormant_customers": round(avg_dormant_spend, 2),
            "last_order_recency_distribution": {
                "mean": round(recency_stats['mean'], 2),
                "std": round(recency_stats['std'], 2),
                "min": int(recency_stats['min']),
                "25%": round(recency_stats['25%'], 2),
                "50%": round(recency_stats['50%'], 2),
                "75%": round(recency_stats['75%'], 2),
                "max": int(recency_stats['max'])
            },
            "suggestion": f"The average dormant customer used to spend around ${avg_dormant_spend:.2f} per order. A win-back offer should be compelling relative to this amount."
        }
    else:
        miss_you_analysis = {
            "target_customer_count": 0,
            "dormancy_trigger_point_days": CONFIG['dormancy_threshold_days'],
            "avg_spend_of_dormant_customers": 0,
            "last_order_recency_distribution": {},
            "suggestion": "No dormant customers found for miss you coupon analysis."
        }

    if len(new_customers_df) > 0:
        avg_first_order = new_customers_df['Average_Spend_Per_Order'].mean()
        joining_bonus_analysis = {
            "target_customer_count": len(new_customers_df),
            "avg_first_order_value": round(avg_first_order, 2),
            "suggestion": f"The average new customer spends ${avg_first_order:.2f} on their first order. A joining bonus should provide value but protect margins on this initial amount."
        }
    else:
        joining_bonus_analysis = {
            "target_customer_count": 0,
            "avg_first_order_value": 0,
            "suggestion": "No new customers found for joining bonus analysis."
        }

    additional_insights = {
        "high_value_customers": {
            "count": len(df[df['Total_Spend_By_Customer'] > df['Total_Spend_By_Customer'].quantile(0.8)]),
            "threshold": round(df['Total_Spend_By_Customer'].quantile(0.8), 2),
            "avg_clv": round(df[df['Total_Spend_By_Customer'] > df['Total_Spend_By_Customer'].quantile(0.8)]['Total_Spend_By_Customer'].mean(), 2)
        },
        "order_frequency_insights": {
            "single_order_customers": len(df[df['Total_Orders_Placed'] == 1]),
            "repeat_customers": len(df[df['Total_Orders_Placed'] > 1]),
            "high_frequency_customers": len(df[df['Total_Orders_Placed'] >= 5])
        }
    }

    final_summary = {
        "data_source": csv_url,
        "analysis_timestamp": pd.Timestamp.now().isoformat(),
        "analysis_config": CONFIG,
        "financial_summary": financial_summary,
        "customer_segments": customer_segments,
        "coupon_strategy_insights": {
            "stamp_card": stamp_card_analysis,
            "miss_you": miss_you_analysis,
            "joining_bonus": joining_bonus_analysis,
        },
        "additional_insights": additional_insights
    }

    return json.dumps(final_summary, indent=2)

async def main():
    base_url = "http://localhost:8000"
    filename = "Customer_KPIs_KnownPhonesOnly.csv"
    if len(sys.argv) == 2:
        filename = sys.argv[1]
    elif len(sys.argv) == 3:
        base_url = sys.argv[1]
        filename = sys.argv[2]
    csv_url = f"{base_url}/{filename}"
    summary_json = await analyze_kpis(csv_url)
    print(summary_json)

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
